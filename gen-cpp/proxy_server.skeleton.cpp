// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "proxy.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <curl/curl.h>
#include <boost/algorithm/string/predicate.hpp>
#include <boost/algorithm/string.hpp>
#include <iostream>
#include <fstream>

#include "../cache_src/cache_FIFO.h"
#include "../cache_src/cache_rand.h"
#include "../cache_src/cache_MAXS.h"
#include "../cache_src/cache_LRU.h"


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;



class proxyHandler : virtual public proxyIf {
 public:
  proxyHandler() {

    cache_req_times = 0;
    cache_hit_times = 0;
    cache_miss_times = 0;
    no_cache = false;
    // Your initialization goes here
  }

  void req_from_client(std::string& _return, const std::string& url) {
    // Your implementation goes here
    CURL *curl;
    CURLcode res;
    std::string _res;

    std::ofstream file ("./hit_rate.txt", std::ios::out|std::ios::app);

    if(boost::starts_with(url, "http")){

          cache_req_times++;

	  if(no_cache)         //for no cache policy   
		  _res =  "NULL";
	  else
		  _res = p_cache->get_content(url);
	  if(_res == "NULL"){

            cache_miss_times++;

            curl = curl_easy_init();
            if (curl) {
                    
                    // Def: CURLcode curl_easy_setopt(CURL *handle, OPTIONS, char *URL);
                    curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); // Note: the url should be char* type
                    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
                    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &_return);
                    res = curl_easy_perform(curl);
		    curl_easy_cleanup(curl);

		    if(no_cache) //for no cache policy
			    DEBUG_MSG("No Cache existing, fetch %ld bytes from %s\n", (long int)(_return.size()), url.c_str());
		    else
			    p_cache->update(url, _return);

	    }

	  }
          else{

            cache_hit_times++;

            DEBUG_MSG("...cache hit: %s of %d bytes\n", url.c_str(), _res.size());
            _return = _res;
          }

          DEBUG_MSG("resp_to_client: %d bytes\n", _return.size());

    } // end of starts with http

    else if(boost::starts_with(url, "no_cache")){

      no_cache = true;

      printf("...no cache ... ");
      file << "...no cache ... ";

    }

    else if(boost::starts_with(url, "FIFO")){

      std::vector<std::string> str_cache_size;
      int int_cache_max;

      no_cache = false;

      boost::split(str_cache_size, url, boost::is_any_of(" "));
      int_cache_max = atoi(str_cache_size.at(1).c_str());

      printf("...creating FIFO   cache with maximum: %d bytes ... ", int_cache_max);
      file << "...creating FIFO   cache with maximum: " << int_cache_max << "bytes ..."; 

      p_cache = std::shared_ptr<cache_FIFO>(new cache_FIFO(int_cache_max));
    }

    else if(boost::starts_with(url, "rand")){

      std::vector<std::string> str_cache_size;
      int int_cache_max;

      no_cache = false;

      boost::split(str_cache_size, url, boost::is_any_of(" "));
      int_cache_max = atoi(str_cache_size.at(1).c_str());

      printf("...creating random cache with maximum: %d bytes ... ", int_cache_max);
      file << "...creating random cache with maximum: " << int_cache_max << "bytes ...";

      p_cache = std::shared_ptr<cache_rand>(new cache_rand(int_cache_max));
    }

    else if(boost::starts_with(url, "MAXS")){

      std::vector<std::string> str_cache_size;
      int int_cache_max;

      no_cache = false;

      boost::split(str_cache_size, url, boost::is_any_of(" "));
      int_cache_max = atoi(str_cache_size.at(1).c_str());

      printf("...creating MAXS   cache with maximum: %d bytes ... ", int_cache_max);
      file << "...creating MAXS   cache with maximum: " << int_cache_max << "bytes ...";

      p_cache = std::shared_ptr<cache_MAXS>(new cache_MAXS(int_cache_max));
    }

    else if(boost::starts_with(url, "LRU")){

      std::vector<std::string> str_cache_size;
      int int_cache_max;

      no_cache = false;

      boost::split(str_cache_size, url, boost::is_any_of(" "));
      int_cache_max = atoi(str_cache_size.at(1).c_str());

      printf("...creating LRU    cache with maximum: %d bytes ... ", int_cache_max);
      file << "...creating LRU    cache with maximum: " << int_cache_max << "bytes ...";

      p_cache = std::shared_ptr<cache_LRU>(new cache_LRU(int_cache_max));
    }

    else{

      printf("cache req: %d, hit: %d, miss: %d\n", cache_req_times, cache_hit_times, cache_miss_times);
      file << "cache req: " << cache_req_times << ", hit: " << cache_hit_times << ", miss: " << cache_miss_times << std::endl;
      no_cache = false;

      cache_req_times = 0;
      cache_hit_times = 0;
      cache_miss_times = 0;

    }
} // end of req_from_client


  static size_t WriteCallback(void *ptr, size_t size, size_t nmemb, void *stream)
  {
    ((std::string*)stream)->append((char*)ptr, size * nmemb);
    return size * nmemb;
  }

private:
  std::shared_ptr<cache_base> p_cache;
  int cache_hit_times;
  int cache_miss_times;
  int cache_req_times;
  bool no_cache;// for no cache policy

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<proxyHandler> handler(new proxyHandler());
  shared_ptr<TProcessor> processor(new proxyProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

